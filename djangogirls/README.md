## 인터넷은 어떻게 작동할까요

- 웹사이트란?
  - 파일의 묶음
  - 하드디스크처럼 저장할 공간이 필요함 → 서버
  - 서버: 데이터를 제공하는 주체
    - 모든 컴퓨터를 연결할 수는 없음.
    - 여러 서버를 거쳐서 통과함.
- 웹의 작동 과정
  - 편지(데이터 패킷) → 가장 가까운 우체국(라우터) → 다음 우체국 → … → 주소지
  - url → DNS(도메일 주소 시스템) → IP주소
- 상세한 프로세스
  - URL 파싱
  - DNS 조회
  - IP 주소 탐색 과정
  - 서버와의 연결
  - HTTP 요청
  - 웹 서버와 WAS의 요청 처리/응답

### URL 파싱

- url의 구조를 해석함.
- IP 주소
  - 컴퓨터가 가지는 주소
  - 통신을 위한 고유한 주소
- 도메인
  - ip 주소는 인간이 이해하기 너무 어려움. → 도메인으로 관리
  - ex) 216.58.220.110 → [naver.com](http://naver.com)
- 도메인 체계

  - 역트리 형태

- DNS
  - 도메인 주소 체계
  - 도메인을 사용하여 웹 사이트에 접근할 수 있도록 함.
  - 도메인 입력 → DNS → IP 주소
- URL
  - 클라이언트가 불러올 리소스를 요청하기 위해 필요한 정보의 집합
  - 프로토콜, 호스트(네트워크에 연결된 컴퓨터), 포트, 리소스 경로, 쿼리
  - 프로토콜
    - 통신 규약
    - 나는 이렇게 주면 너는 이렇게 받으렴
    - HTTP: Hypertext Transfer Protocol
    - HTTP: Hypertext Transfer Protocol Secure
  - 포트
    - 외부 장비에 접속하기 위한 소프트웨어 상의 플러그
    - 보통 하나의 컴푸터에는 여러 프로그램이 동시에 실행되고 있음.
    - 나에게 접속하려고 하는 프로그램이 무엇인지를 알려줘야 함. → 포트
    - 장고는 8000 포트를 사용함.

### DNS 조회

- 도메인에서 IP 주소를 구하는 데 시간이 걸림
- 이미 방문했던 도메인의 IP 주소는 브라우저에 저장해둠. (캐싱)
- 캐싱을 먼저 확인 → 없으면 DNS에 ip 주소 요청
- 빠른 접속을 위한 단계

### IP 주소 탐색

- 여러 통신사의 DNS 서버에서 등록됨. → Local DNS
- 컴퓨터 LAN 선으로 인터넷 연결 → 인터넷을 사용할 수 있도록 통신사에서 IP 할당 → 통신사의 DNS 서버에 IP 주소가 등록됨.
- 작은 우체국에서 큰 우체국으로 이동하듯이 DNS도 여러 단계를 거쳐 목적지로 이동 → Recursive Query
- 재귀적 요청으로 속도가 느림 → 캐싱 필요

### 서버와 연결

- 패킷 통신
  - pack + bucket
  - 데이터를 작은 조각으로 쪼개서 보냄
  - 대부분의 인터넷 통신에서 패킷 통신을 사용함.
- TCP/IP
  - 패킷통신을 위한 프로토콜
  - IP
    - 인터넷 상의 주소 규칙
    - 패킷의 순서가 바뀌거나 누락되더라도 최대한 빨리 보내는 것이 목표
  - TCP
    - IP 위에서 동작
    - 데이터 전달을 관리하는 규칙
    - 작게 나누고 조립하는 과정 (패킷 생성 병합)
    - 순서를 다시 맞추거나 누락된 패킷을 판단하여 재요청하는 프로토콜
- 서버와 TCP 소켓의 연결

  - IP 주소를 받으면 해당 서버와 연결
  - 서버와 데이터를 통신하기 위해서는 TCP 소켓을 연결해야 함.

    - 소켓: 클라이언트와 서버를 연결하고 양방향 통신이 가능하도록 하는 기술
    - 3-way handshake

      - 서버와 사전에 데이터 전송을 준비하는 과정
      - 클라이언트가 HTTP 통신을 사용하여 서버에 소켓 통신이 가능한지 요청을 보냄.
        - 이때 Upgrade, Connection, WebSocket에 대한 정보를 함께 전송함.
        - syn 패킷이라고도 부름
      - 서버가 웹 소켓 통신을 할 수 있다면 101 응답을 보냄
        - Sec-WebSocket-Key에 문자를 더한 후 암호화
        - 암호를 Sec-WebSocket-Apccet로 전송
        - ACK, SYN flag가 설정된 패킷이라고도 부름
      - 클라이언트가 서버에게 응답 확인을 보냄
        - ACK 패킷이라고도 부름.
      - ws 또는 wss 프로토콜로 양방향 통신을 진행
      - 사실 HTTPS면 TLS 협상이라는 handshake 과정을 한번 더 거쳐야 함.
        - TLS 협상: 정보를 암호화하여 송수신하는 프로토콜
        - 암호화된 데이터를 교환하기 위한 협상의 과정

      ```jsx
      let socket = new WebSocket("ws://chanstory.dev");

      GET /chat
      Host: https://chanstory.dev
      Origin: https://chanstory.dev
      Connection: Upgrade
      Upgrade: websocket
      Sec-WebSocket-Key: ...
      Sec-WebSocket-Version: 13

      101 Switching Protocols
      Upgrade: websocket
      Connection: Upgrade
      Sec-WebSocket-Accept: ...
      ```

    - 4-way-handshake
      - 데이터를 수신받은 이후 서버와의 연결을 종료할 때 사용
      - 클라이언트가 FIN 플래그를 서버에 전송
      - 서버는 ack 메시지를 보내고 통신이 끝날 때까지 기다림.
        - 만약 서버가 클라이언트에게 데이터를 보내고 있는 경우, fin 플래그가 먼저 도착하면 데이터 유실이 발생할 수 있음.
        - 일정 시간동안 기다려서 남은 패킷을 모두 보내도록 함. → 이후에 FIN 플래그 보내기
      - 서버가 통신이 끝나면 클라이언트에서 FIN 플래스 전송
      - 클라이언트는 ACK 메시지를 서버에 보냄

### HTTP 요청

- TCP 연결이 완료되면 데이터 요청이 시작됨.
- Request 메시지 구조
  - 시작줄, 헤더, 본문으로 구성됨.
  - 시작줄
    - 메서드: 수행하는 동작을 알려줌. (GET, POST, PUT, PATCH, DELETE)
    - Path: 리소스의 경로
    - 프로토콜 버전
  - 헤더
    - 요청에 대한 정보를 담음.
  - 본문
    - 요청할 때 함께 보낼 데이터를 담음.
- Response 메시지 구조
  - 시작줄 - 프로토콜 버전 - Status Code
  - Status Message: 상태 코드에 대한 짧은 설명
  - 헤더
    - HTTP 해더
  - 바디
    - 요청한 데이터를 담아주는 부분
    - HTML을 담아줌
    - 클라이언트는 해당 HTML을 사용하여 화면에 렌더링

| 200(성공)            | 200 | GET 성공                                                  |
| -------------------- | --- | --------------------------------------------------------- |
|                      | 204 | 성공했으나 데이터는 없음                                  |
|                      | 205 | 성공했으나 화면 새로고침하도록 권고                       |
|                      | 206 | 성공했으나 일부 데이터만 반환                             |
| 300(리다이렉션)      | 301 | 요청한 자원이 새 URL에 존재                               |
|                      | 303 | 요청한 자원이 임시 주소에 존재                            |
|                      | 304 | 요청한 자원이 변경되지 않아 캐싱된 자원을 사용하도록 권고 |
| 400(클라이언트 에러) | 400 | 잘못된 요청                                               |
|                      | 401 | 권한 없는 요청                                            |
|                      | 403 | 서버에서 해당 자원에 대해 접근을 금지시킴                 |
|                      | 405 | 요청 메서드가 허용되지 않음.                              |
|                      | 409 | 최신 자원이 아닌데 업데이트 (버전 충돌)                   |
| 500(서버 에러)       | 501 | 서버가 요청한 동작을 수행할 수 없는 경우                  |
|                      | 503 | 서버 과부하 또는 유지보수 중                              |

### 웹 서버와 WAS의 요청/응답

- 정적 페이지와 동적 페이지
  - 정적페이지: 언제나 같은 화면을 보여주는 페이지
  - 동적 페이지: 서버에서 추가적인 처리가 필요한 페이지, 접속할 때마다 다른 화면
- 웹 서버
  - 웹 서버가 있는 컴퓨터
  - 클라이언트로부터 HTTP 요청을 받아 정적 콘텐츠들을 저공하는 컴퓨터 프로그램
  - 정적인 페이지에 대해 응답함.
  - 동적 페이지 → WAS에게 요청 처리를 맡김.
  - 대표적인 웹 서버: Apache, WebtoB, NginX
- WAS
  - Web Application Server
  - 웹 어플리케이션: 웹에서 실행되는 프로그램
  - WAS: 웹 어플리케이션을 실행시켜 필요한 기능 수행 → 결과를 웹 서버로 전달 (미들웨어)
    - 웹 서버와 웹 컨테이너가 합쳐짐
    - 웹 컨테이너: JSP, Servlet을 실행시킬 수 있음. (구동환경 제공)
    - JSP: 정적인 HTML 코드에 java코드를 넣어 동적으로 웹을 구성하는 웹 어플리케이션 도구
    - Servelet: 클라이언트가 어떠한 요청을 했을 때 그에 대한 결과를 다시 전송하는 자바 프로그램

```jsx
장고는 웹 서버가 아닙니다..
장고는 웹 어플리케이션 프레임워크입니다..

우리가 사용하는 아래 코드
python manage.py runserver
는 debug 용으로 local에서만 사용해야 함.
실제 production 환경에서는 추천하지 않음. (보안/퍼포먼스 이슈, 공식문서 참고)
AWS에서 NGINX나 apache를 적용하는 여러 방법이 있음. (요즘은 NGINX 많이 사용)

웹 서버: 웹 페이지를 클라이언트로 전달
그림, css, js 등 정적인 정보 반환
Apache: 하나의 request에 하나의 thread
Nginx: Event-Driven 방식의 비동기 처리
```

- WAS가 서버 역할까지 하면 안되나요?
  - was는 동적 데이터를 처리하기 때문에 서버 부하가 생기기 쉬움.
  - SSL 암복호화 처리에서 웹 서버를 사용하면 물리적으로 분리되어 보안 강화
  - 여러 WAS를 연결해 로드 밸런싱 가능
- 이상적인 웹서비스 아키텍처
  - 서버를 기능에 따라 분리
  - 웹 브라우저 → 웹 서버 → 애플리케이션 서버 → 데이터 서버

```jsx
wsgi는 무엇인가요?
웹 서버에 동적 페이지 요청이 들어오면 웹 서버가 파이썬 프로그램을 호출해야 함.
그런데 웹 서버에는 파이썬이 없음
-> WSGI 서버를 사용

웹 서버에 동적 요청
-> 웹 서버가 WSGI 서버 호출
-> WSGI 서버가 파이썬 프로그램 호출
-> 동적 페이지 요청 처리

WSGI를 사용하려면 gnuicorn 또는 uwsgi가 필요함.
Gunicorn을 많이 사용하는 추세임.
```

## 장고란 무엇인가요?

- 웹 서버에 요청이 오면 장고로 전달됨.
  - 정확히 말하면 “동적 페이지 요청”이 장고로 전달됨.
- urlsolver가 웹 페이지 주소를 가져와 자신이 할 일을 확인함.
  - 패턴 목록을 자신의 URL과 일일이 대조
  - 일치하는 패턴이 있으면 해당 요청을 view로 넘김
- view
  - 특정 정보를 데이터베이스에서 찾음.
  - 권한 확인
  - 해당 요청을 수행 후 답장 생성 → 클라이언트로 보냄.
